<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Picidae </title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
<div id="root">
    <div class="main" data-reactroot="" data-reactid="1" data-react-checksum="-1233438610"><header class="clearfix eux-header" data-reactid="2"><div class="eux-header-top" data-reactid="3"><a href="javascript:void(0);" class="eux-portable-menu" data-reactid="4"></a><nav class="menu-primary-container" data-reactid="5"><ul id="menu-primary" class="menu" data-reactid="6"><li id="menu-item-25" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-25" data-reactid="7"><a href="/" data-reactid="8">HOME</a></li><li id="menu-item-45" class="menu-item menu-item-type-custom menu-item-object-custom current-menu-ancestor current-menu-parent menu-item-has-children menu-item-45" data-reactid="9"><a href="/" data-reactid="10">BLOG</a><ul class="sub-menu" data-reactid="11"><li id="menu-item-63" class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="12"><a href="/ue" data-reactid="13">交互</a></li><li id="menu-item-67" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-67" data-reactid="14"><a href="/ui" data-reactid="15">视觉</a></li><li id="menu-item-64" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-64" data-reactid="16"><a href="/fe" data-reactid="17">前端</a></li><li id="menu-item-62" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-62" data-reactid="18"><a href="/team" data-reactid="19">团队</a></li></ul></li><li id="menu-item-46" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-46" data-reactid="20"><a href="/tools" data-reactid="21">TOOLS</a></li><li id="menu-item-112" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-112" data-reactid="22"><a href="/works" data-reactid="23">WORKS</a></li><li id="menu-item-138" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-138" data-reactid="24"><a href="/jobs" data-reactid="25">JOBS</a></li><li id="menu-item-50" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-50" data-reactid="26"><a href="/about-us" data-reactid="27">ABOUT US</a></li></ul></nav></div></header><div class="eux-singular clearfix" data-reactid="28"><div class="container-singular clearfix" data-reactid="29"><nav class="menu-categories-container" data-reactid="30"><ul id="menu-categories" class="menu" data-reactid="31"><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="32"><span data-reactid="33"><a href="/" data-reactid="34">全部</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="35"><span data-reactid="36"><a href="/ue" data-reactid="37">交互</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="38"><span data-reactid="39"><a href="/ui" data-reactid="40">视觉</a></span></li><li class="current-menu-item menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="41"><span data-reactid="42"><a href="/fe" data-reactid="43">前端</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="44"><span data-reactid="45"><a href="/team" data-reactid="46">团队</a></span></li></ul></nav><div class="inner clearfix" data-reactid="47"><div class="article-meta" data-reactid="48"><h1 class="title" data-reactid="49">脚本的动态加载</h1><div class="eux-page-detail" data-reactid="50"><span data-reactid="51"><em data-reactid="52">by.</em><!-- react-text: 53 -->sucer<!-- /react-text --></span><span data-reactid="54">2015-11-13</span></div></div><article data-reactid="55"><h3 id="脚本的动态加载" data-reactid="56"><a href="#%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD" aria-hidden="true" data-reactid="57"><span class="icon icon-link" data-reactid="58"></span></a><!-- react-text: 59 -->脚本的动态加载<!-- /react-text --></h3><!-- react-text: 60 -->
<!-- /react-text --><blockquote data-reactid="61"><!-- react-text: 62 -->
<!-- /react-text --><blockquote data-reactid="63"><!-- react-text: 64 -->
<!-- /react-text --><p data-reactid="65">我们平时如何挂载脚本?  </p><!-- react-text: 66 -->
<!-- /react-text --></blockquote><!-- react-text: 67 -->
<!-- /react-text --></blockquote><!-- react-text: 68 -->
<!-- /react-text --><p data-reactid="69">众所周知，在web应用中，我们时常需要使用js脚本对应用做这样或者那样的操作。而仙贝们为了解放大家的双手，降低大家的开发成本，创造了很多具有各种用途，或者针对对应问题的解决方案。这些解决方案，被称作框架和库。  </p><!-- react-text: 70 -->
<!-- /react-text --><p data-reactid="71">而作为这些脚本的使用者，我们只需要简单而又传统的将脚本使用script标签插入我们的应用中就行了。  </p><!-- react-text: 72 -->
<!-- /react-text --><pre data-reactid="73"><code data-query="{}" data-lang="data-lang" data-reactid="74">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><!-- react-text: 75 -->
<!-- /react-text --><p data-reactid="76">如上文所说，这是简单而又传统的使用方法。事实上在技术快速迭代的今天，传统方式有时候并不能满足我们的需求。当一个webapp含有过多的功能的时候，我们的脚本可能越来越大。而用户的体验则是：这网站打开真慢啊～～～  </p><!-- react-text: 77 -->
<!-- /react-text --><p data-reactid="78">然而事实上我们功能做得相当的多，效果做得相当的好，大部分用户其实只是使用了其中的某几个基础功能而已。但只是为了所有功能能够使用而增加了加载量，似乎有些得不偿失。  </p><!-- react-text: 79 -->
<!-- /react-text --><blockquote data-reactid="80"><!-- react-text: 81 -->
<!-- /react-text --><blockquote data-reactid="82"><!-- react-text: 83 -->
<!-- /react-text --><p data-reactid="84">然后，我们有了动态加载脚本的想法  </p><!-- react-text: 85 -->
<!-- /react-text --></blockquote><!-- react-text: 86 -->
<!-- /react-text --></blockquote><!-- react-text: 87 -->
<!-- /react-text --><p data-reactid="88"><!-- react-text: 89 -->从<!-- /react-text --><em data-reactid="90">Netscape Navigator 4.0</em><!-- react-text: 91 -->为起点，浏览器厂商们都开始支持起了不同形态的动态html。通过dom api，程序猿们可以轻松的对节点进行各种操作。于是对我们来说，又有了新的方法去加载脚本。  <!-- /react-text --></p><!-- react-text: 92 -->
<!-- /react-text --><pre data-reactid="93"><code data-query="{}" data-lang="data-lang" data-reactid="94">var script = document.createElement(&#x27;script&#x27;);
script.async = true;
script.src = &#x27;myScript.js&#x27;;
document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script);
</code></pre><!-- react-text: 95 -->
<!-- /react-text --><p data-reactid="96">当然了，这样的写法是最基础的增加方法。在这样的写法下，我们无法得知脚本到底有没有加载完，如果依赖脚本没有加载并解释完毕，那么我们加载它就没有任何意义，还会因此阻断所有相关操作。  </p><!-- react-text: 97 -->
<!-- /react-text --><p data-reactid="98">谢天谢地，天无绝人之路，浏览器老板们还是给我们提供了方法对脚本加载情况进行探知。我们所知的onreadystatechange事件和onload事件可以帮我们判断脚本是否加载完毕～  </p><!-- react-text: 99 -->
<!-- /react-text --><pre data-reactid="100"><code data-query="{}" data-lang="data-lang" data-reactid="101">script.onreadystatechange = script.onload = function (evt) {
    var evt = evt ? evt : window.event;
    if (!evt.readyState || evt.readyState === &#x27;loaded&#x27; || evt.readyState === &#x27;complete&#x27;) {
        cb &amp;&amp; cb();
        script.onreadystatechange = script.onload ＝ null;
        script.parent.removeChild(script);
        script = null;
    }
}
</code></pre><!-- react-text: 102 -->
<!-- /react-text --><blockquote data-reactid="103"><!-- react-text: 104 -->
<!-- /react-text --><blockquote data-reactid="105"><!-- react-text: 106 -->
<!-- /react-text --><p data-reactid="107">作为一个正常人，我们想不想加载更多东西呢？  </p><!-- react-text: 108 -->
<!-- /react-text --></blockquote><!-- react-text: 109 -->
<!-- /react-text --></blockquote><!-- react-text: 110 -->
<!-- /react-text --><p data-reactid="111">想！当然想。作为一个正常人，我们极其希望也load别的东西过来，那现在我们还有什么东西可以通过动态加载呢？css／picture／function都可以成为我们的加载对象。这时候，我们就该有一个简单的加载器了，聚合我们想要的功能，让我们解放双手！  </p><!-- react-text: 112 -->
<!-- /react-text --><pre data-reactid="113"><code data-query="{}" data-lang="data-lang" data-reactid="114">var handler = {
    js: jsHandler,
    css: cssHandler,
    fn: fnHandler
};

var Loader = function (src, type) {

    if (src === undefined) {
        throw new Error(&#x27;木有参数&#x27;);
    }

    //  修正参数
    if (!type) {
        if (typeof src === &#x27;string&#x27;) {
            if (/\.css$|\.css\?/i.test(src)) {
                type = &#x27;css&#x27;;
            }
            if (/\.js$|\.js\?/i.test(src)) {
                type = &#x27;js&#x27;;
            }
        }
        if (typeof src === &#x27;function&#x27;) {
            type = &#x27;fn&#x27;
        }
    }

    type = type || &#x27;js&#x27;;

    handler[type](src);
};

function jsHandler(src) {}

function cssHandler(href) {}

function fnHandler(fn) {}
</code></pre><!-- react-text: 115 -->
<!-- /react-text --><blockquote data-reactid="116"><!-- react-text: 117 -->
<!-- /react-text --><blockquote data-reactid="118"><!-- react-text: 119 -->
<!-- /react-text --><p data-reactid="120">如何填充我们的函数  </p><!-- react-text: 121 -->
<!-- /react-text --></blockquote><!-- react-text: 122 -->
<!-- /react-text --></blockquote><!-- react-text: 123 -->
<!-- /react-text --><p data-reactid="124"><img src="http://ww3.sinaimg.cn/large/43b712ebgw1ey33fsbjl3j20hd0lhtfg.jpg" data-reactid="125"/></p><!-- react-text: 126 -->
<!-- /react-text --><p data-reactid="127">我们有了处理不同类型加载项的逻辑，但首先，我们还是要完善jsHandler函数  </p><!-- react-text: 128 -->
<!-- /react-text --><blockquote data-reactid="129"><!-- react-text: 130 -->
<!-- /react-text --><blockquote data-reactid="131"><!-- react-text: 132 -->
<!-- /react-text --><p data-reactid="133">获取head元素  </p><!-- react-text: 134 -->
<!-- /react-text --></blockquote><!-- react-text: 135 -->
<!-- /react-text --></blockquote><!-- react-text: 136 -->
<!-- /react-text --><pre data-reactid="137"><code data-query="{}" data-lang="data-lang" data-reactid="138">var doc = document;
var head = doc.head || doc.getElementsByTagName(&quot;head&quot;)[0] || doc.documentElement;
</code></pre><!-- react-text: 139 -->
<!-- /react-text --><p data-reactid="140">将document和head缓存起来，以便多次使用，这可以提高一点点的性能…  </p><!-- react-text: 141 -->
<!-- /react-text --><blockquote data-reactid="142"><!-- react-text: 143 -->
<!-- /react-text --><blockquote data-reactid="144"><!-- react-text: 145 -->
<!-- /react-text --><p data-reactid="146">为jsHandler完善加载部分  </p><!-- react-text: 147 -->
<!-- /react-text --></blockquote><!-- react-text: 148 -->
<!-- /react-text --></blockquote><!-- react-text: 149 -->
<!-- /react-text --><pre data-reactid="150"><code data-query="{}" data-lang="data-lang" data-reactid="151">function jsHandler(src, callback) {
    var script = doc.createElement(&#x27;script&#x27;);
    script.async = true;
    script.src = src;

    // 对支持onload事件的浏览器做处理
    var hasOnload = &#x27;onload&#x27; in script;
    if (hasOnload) {
        script.onload = jsOnload;
        script.onerror = function () {
            jsOnload(true);
        }
    }

    // 对支持onreadystatechange的浏览器做处理
    else {
        script.onreadystatechange = function() {
            if (/loaded|complete/.test(script.readyState)) {
                jsOnload();
            }
        }
    }

    head.appendChild(script);

    // 当事件
    function jsOnload(error) {
        isTimeout = false;
        script.onload = script.onerror = script.onreadystatechange = null;
        head.removeChild(script);
        script = null;
        callback(error);
    }
}
</code></pre><!-- react-text: 152 -->
<!-- /react-text --><pre data-reactid="153"><code data-query="{}" data-lang="data-lang" data-reactid="154">在上面这段代码中，我们为加载js做了一系列处理，由于浏览器厂商的实现问题，我们要对脚本是否加载成功或失败作出判断，这是个很麻烦的事情，尤其是对需要向下兼容的同学来说。
</code></pre><!-- react-text: 155 -->
<!-- /react-text --><p data-reactid="156"><!-- react-text: 157 -->从<!-- /react-text --><a href="http://qianduanblog.com/post/headjs.html" data-reactid="158">headjs</a><!-- react-text: 159 -->这篇文章的注释来看，脚本是否加载完毕依赖于onload事件，而ie9及以下依赖于对状态标志进行load或者complete字符的检测。  <!-- /react-text --></p><!-- react-text: 160 -->
<!-- /react-text --><pre data-reactid="161"><code data-query="{}" data-lang="data-lang" data-reactid="162">// IE 7/8 (2 events on 1st load)
// 1) event.type = readystatechange, s.readyState = loading
// 2) event.type = readystatechange, s.readyState = loaded

// IE 7/8 (1 event on reload)
// 1) event.type = readystatechange, s.readyState = complete 

// event.type === &#x27;readystatechange&#x27; &amp;&amp; /loaded¦complete/.test(s.readyState)

// IE 9 (3 events on 1st load)
// 1) event.type = readystatechange, s.readyState = loading
// 2) event.type = readystatechange, s.readyState = loaded
// 3) event.type = load            , s.readyState = loaded

// IE 9 (2 events on reload)
// 1) event.type = readystatechange, s.readyState = complete 
// 2) event.type = load            , s.readyState = complete 

// event.type === &#x27;load&#x27;             &amp;&amp; /loaded¦complete/.test(s.readyState)
// event.type === &#x27;readystatechange&#x27; &amp;&amp; /loaded¦complete/.test(s.readyState)

// IE 10 (3 events on 1st load)
// 1) event.type = readystatechange, s.readyState = loading
// 2) event.type = load            , s.readyState = complete
// 3) event.type = readystatechange, s.readyState = loaded

// IE 10 (3 events on reload)
// 1) event.type = readystatechange, s.readyState = loaded
// 2) event.type = load            , s.readyState = complete
// 3) event.type = readystatechange, s.readyState = complete 

// event.type === &#x27;load&#x27;             &amp;&amp; /loaded¦complete/.test(s.readyState)
// event.type === &#x27;readystatechange&#x27; &amp;&amp; /complete/.test(s.readyState)

// Other Browsers (1 event on 1st load)
// 1) event.type = load, s.readyState = undefined

// Other Browsers (1 event on reload)
// 1) event.type = load, s.readyState = undefined            

// event.type == &#x27;load&#x27; &amp;&amp; s.readyState = undefined
</code></pre><!-- react-text: 163 -->
<!-- /react-text --><p data-reactid="164">当然，如果遇到了既不支持onload又不支持onreadystatechange的浏览器的时候，我们只能另寻他法了。  </p><!-- react-text: 165 -->
<!-- /react-text --><p data-reactid="166">如果要加载的脚本是你写的，那你自己可以处理～如果加载的脚本不是你写的～哦喽，不在本文讨论范围之内～  </p><!-- react-text: 167 -->
<!-- /react-text --><blockquote data-reactid="168"><!-- react-text: 169 -->
<!-- /react-text --><blockquote data-reactid="170"><!-- react-text: 171 -->
<!-- /react-text --><p data-reactid="172">当你需要jsHandler检测加载是否超时的时候  </p><!-- react-text: 173 -->
<!-- /react-text --></blockquote><!-- react-text: 174 -->
<!-- /react-text --></blockquote><!-- react-text: 175 -->
<!-- /react-text --><p data-reactid="176">我们为jsHandler增加一个参数timeout，并在函数中实现如下逻辑  </p><!-- react-text: 177 -->
<!-- /react-text --><pre data-reactid="178"><code data-query="{}" data-lang="data-lang" data-reactid="179">function jsHandler(src, callback, timeout) {
    ...
    // 检测是否超时的标志
    var isTimeout = true;
    ...

    if (timeout) {
        setTimeout(timeoutHandler, timeout);
    }

    head.appendChild(script);

    function jsOnload(error) {
        // 当在时间内完成操作时，不管是否成功，将超时标志设为false
        isTimeout = false;
        script.onload = script.onerror = script.onreadystatechange = null;
        head.removeChild(script);
        script = null;
        callback(error);
    }

    function timeoutHandler() {
        // 如果标志未改变，认为其超时
        if (isTimeout) {
            jsOnload(true);
        }
    }
}
</code></pre><!-- react-text: 180 -->
<!-- /react-text --><blockquote data-reactid="181"><!-- react-text: 182 -->
<!-- /react-text --><blockquote data-reactid="183"><!-- react-text: 184 -->
<!-- /react-text --><p data-reactid="185">当我们同步执行代码的时候  </p><!-- react-text: 186 -->
<!-- /react-text --></blockquote><!-- react-text: 187 -->
<!-- /react-text --></blockquote><!-- react-text: 188 -->
<!-- /react-text --><p data-reactid="189">当我们需要加载一个或者多个脚本的时候，我们会发现，“奥我次奥，怎么请求了那么多次呢？这不科学。”  </p><!-- react-text: 190 -->
<!-- /react-text --><p data-reactid="191">这是因为我们的loader在多处被调用或同步调用了，于是我们想啊，搞个map纪录缓存算了。于是乎：  </p><!-- react-text: 192 -->
<!-- /react-text --><p data-reactid="193">－ 我们需要一些变量  </p><!-- react-text: 194 -->
<!-- /react-text --><pre data-reactid="195"><code data-query="{}" data-lang="data-lang" data-reactid="196">// 用作存储脚本信息
var cache = {};
// 用作生成不重复的客户端id
var _cid = 0;
// 用作存储其他loader实例需要运行的脚本任务
var processCache = {};

// 加载状态标识
var DONE = &#x27;done&#x27;;
var REJECTED = &#x27;rejected&#x27;;
var PENDING = &#x27;pending&#x27;;
</code></pre><!-- react-text: 197 -->
<!-- /react-text --><ul data-reactid="198"><!-- react-text: 199 -->
<!-- /react-text --><li data-reactid="200">我们需要产生不同的存储id</li><!-- react-text: 201 -->
<!-- /react-text --></ul><!-- react-text: 202 -->
<!-- /react-text --><pre data-reactid="203"><code data-query="{}" data-lang="data-lang" data-reactid="204">/**
 * 产生客户端id
 * @return {Number} [description]
 */
function cid() {
    return _cid++;
}
</code></pre><!-- react-text: 205 -->
<!-- /react-text --><ul data-reactid="206"><!-- react-text: 207 -->
<!-- /react-text --><li data-reactid="208">我们需要创建一个Script类，new一个实例用于存储任务的基本信息</li><!-- react-text: 209 -->
<!-- /react-text --></ul><!-- react-text: 210 -->
<!-- /react-text --><pre data-reactid="211"><code data-query="{}" data-lang="data-lang" data-reactid="212">/**
 * Script对象，储存需要加载的任务的基本信息
 * @param  {String} uri     uri 地址 | 需要执行的函数
 * @param  {String} type    任务类型
 */
function Script(uri, type) {
    this.uri = uri;
    this.type = type;
    this.cid = cid();
    this.status = PENDING;
}
</code></pre><!-- react-text: 213 -->
<!-- /react-text --><p data-reactid="214">－ 当我们寻找缓存中的任务对象的时候，因该返回正确的对象。怎么寻找缓存呢，当然是通过地址来索引啦  </p><!-- react-text: 215 -->
<!-- /react-text --><pre data-reactid="216"><code data-query="{}" data-lang="data-lang" data-reactid="217">/**
 * 从缓存中获取需要的Script对象
 * 如果没有，新建一个
 * @param  {String} uri     uri 地址 | 需要执行的函数
 * @param  {String} type    任务类型
 * @return {Object}         需要的Script对象
 */
function get(uri, type) {
    // 如果不存在于缓存中，创建一个新的Script对象
    return cache[uri] || (cache[uri] = new Script(uri, type));
}
</code></pre><!-- react-text: 218 -->
<!-- /react-text --><blockquote data-reactid="219"><!-- react-text: 220 -->
<!-- /react-text --><blockquote data-reactid="221"><!-- react-text: 222 -->
<!-- /react-text --><p data-reactid="223">如果我们的脚本或函数有别名怎么办！  </p><!-- react-text: 224 -->
<!-- /react-text --></blockquote><!-- react-text: 225 -->
<!-- /react-text --></blockquote><!-- react-text: 226 -->
<!-- /react-text --><pre data-reactid="227"><code data-query="{}" data-lang="data-lang" data-reactid="228">var alias = {};
/**
 * 获取有别名的Script对象
 * @param  {String} uri     uri 地址 | 需要执行的函数
 * @param  {String} type    任务类型
 * @return {Object}      Script Object
 */
function getCache(uri, type) {
    var src = getAlias(uri);
    return  src ? get(src) : get(uri, type);
}

/**
 * 获取真实地址
 * @param  {String} name [description]
 * @return {[type]}      return uri
 */
function getAlias(name) {
    return alias[name];
}
</code></pre><!-- react-text: 229 -->
<!-- /react-text --><p data-reactid="230">别名的用途在于我们不用多次输入同样长度的uri,或者说是函数。  </p><!-- react-text: 231 -->
<!-- /react-text --><blockquote data-reactid="232"><!-- react-text: 233 -->
<!-- /react-text --><blockquote data-reactid="234"><!-- react-text: 235 -->
<!-- /react-text --><p data-reactid="236">现在，该填充我们的Loader类了。  </p><!-- react-text: 237 -->
<!-- /react-text --></blockquote><!-- react-text: 238 -->
<!-- /react-text --></blockquote><!-- react-text: 239 -->
<!-- /react-text --><p data-reactid="240">我们要很清楚的知道，Loader需要做什么。  </p><!-- react-text: 241 -->
<!-- /react-text --><p data-reactid="242">一个简单的Loader应该可以多次添加需要加载的内容，then或者add方法可以让用户添加任务。那它应该有一个内置的list，可以存储这些待添加的任务。  </p><!-- react-text: 243 -->
<!-- /react-text --><p data-reactid="244">它也应该可以在全部脚本加载完的时候执行我们的callback，那么我们应该实现一个方法接受一个回调，在任务执行完时调用。  </p><!-- react-text: 245 -->
<!-- /react-text --><p data-reactid="246">我们也要可以对某些地址进行别名命名，也需要设置超时时间  </p><!-- react-text: 247 -->
<!-- /react-text --><ul data-reactid="248"><!-- react-text: 249 -->
<!-- /react-text --><li data-reactid="250">实现Loader类</li><!-- react-text: 251 -->
<!-- /react-text --></ul><!-- react-text: 252 -->
<!-- /react-text --><pre data-reactid="253"><code data-query="{}" data-lang="data-lang" data-reactid="254">/**
 * Loader类
 */
var Loader = function () {
    this.list = [];
    this.timeout = 0;
    this.callback = null;
};
</code></pre><!-- react-text: 255 -->
<!-- /react-text --><ul data-reactid="256"><!-- react-text: 257 -->
<!-- /react-text --><li data-reactid="258">实现then方法，使用then的时候应该可以连续使用</li><!-- react-text: 259 -->
<!-- /react-text --></ul><!-- react-text: 260 -->
<!-- /react-text --><pre data-reactid="261"><code data-query="{}" data-lang="data-lang" data-reactid="262">/**
 * 实现的then方法
 * @param  {String} src  地址
 * @param  {String} type 类型
 * @return {Object}      Loader对象
 */
Loader.prototype.then = function(src, type) {
    if (src === undefined) {
        throw new Error(&#x27;木有参数&#x27;);
    }

    //  修正参数
    if (!type) {
        if (typeof src === &#x27;string&#x27;) {
            if (/\.css$|\.css\?/i.test(src)) {
                type = &#x27;css&#x27;;
            }
            if (/\.js$|\.js\?/i.test(src)) {
                type = &#x27;js&#x27;;
            }
        }
        if (typeof src === &#x27;function&#x27;) {
            type = &#x27;fn&#x27;
        }
    }

    type = type || &#x27;js&#x27;;
    this.list.push(getCache(src, type));
    return this;
};
</code></pre><!-- react-text: 263 -->
<!-- /react-text --><ul data-reactid="264"><!-- react-text: 265 -->
<!-- /react-text --><li data-reactid="266">实现done方法</li><!-- react-text: 267 -->
<!-- /react-text --></ul><!-- react-text: 268 -->
<!-- /react-text --><pre data-reactid="269"><code data-query="{}" data-lang="data-lang" data-reactid="270">/**
 * done方法，接受一个callback，在所有任务完成时调用
 * @param  {Function} cb 完成后的回调
 * @return {Object}      第一次调用done后返回一个新的对象
 */
Loader.prototype.done = function(cb) {
    if (this.callback === null) {
        this.callback = cb;
    }
    if (!this.list.length) {
        this.callback &amp;&amp; this.callback();
        return;
    }
    var script = this.list.shift();
    handler[script.type](this, script);
    if (!this.called) {
        this.called = true;
        return new Loader();
    }
};
</code></pre><!-- react-text: 271 -->
<!-- /react-text --><ul data-reactid="272"><!-- react-text: 273 -->
<!-- /react-text --><li data-reactid="274">实现config配置</li><!-- react-text: 275 -->
<!-- /react-text --></ul><!-- react-text: 276 -->
<!-- /react-text --><pre data-reactid="277"><code data-query="{}" data-lang="data-lang" data-reactid="278">Loader.prototype.config = function (opts) {
    this.timeout = opts.timeout || 0;
    if (opts.alias &amp;&amp; !opts.alias.length) {
        for (var i = opts.alias.length - 1; i &gt;= 0; i--) {
            alias[i] = opts.alias[i];
        }
    }
}
</code></pre><!-- react-text: 279 -->
<!-- /react-text --><blockquote data-reactid="280"><!-- react-text: 281 -->
<!-- /react-text --><blockquote data-reactid="282"><!-- react-text: 283 -->
<!-- /react-text --><p data-reactid="284">如何让错误集中显示  </p><!-- react-text: 285 -->
<!-- /react-text --></blockquote><!-- react-text: 286 -->
<!-- /react-text --></blockquote><!-- react-text: 287 -->
<!-- /react-text --><p data-reactid="288">我们需要接入一个resolve方法，Loader类也应该有一个errors的列表来储存每次错误的信息，最后放到callback中集中显示。  </p><!-- react-text: 289 -->
<!-- /react-text --><pre data-reactid="290"><code data-query="{}" data-lang="data-lang" data-reactid="291">function resolve(loader, s) {
    if (s.error) {
        loader.errors.push(s);
    }
    loader.done();
    var cache = processCache[s.cid];
    if (cache &amp;&amp; !cache.length) {
        for (var i = 0, len = cache.length; i &lt; len; i++) {
            cache.shift().loader.done();
        }
    }
}

var Loader = function () {
    this.list = [];
    this.timeout = 0;
    this.errors = [];
    this.callback = null;
};
</code></pre><!-- react-text: 292 -->
<!-- /react-text --><blockquote data-reactid="293"><!-- react-text: 294 -->
<!-- /react-text --><blockquote data-reactid="295"><!-- react-text: 296 -->
<!-- /react-text --><p data-reactid="297">最终，我们将所有的思路组装起来  </p><!-- react-text: 298 -->
<!-- /react-text --></blockquote><!-- react-text: 299 -->
<!-- /react-text --></blockquote><!-- react-text: 300 -->
<!-- /react-text --><pre data-reactid="301"><code data-query="{}" data-lang="data-lang" data-reactid="302">(function (root, factory) {
    if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else {
        // Browser globals
        root.Loader = factory();
    }
}(this, function () {

    // 用作存储脚本信息
    var cache = {};
    // 用作生成不重复的客户端id
    var _cid = 0;
    // 用作存储其他loader实例需要运行的脚本任务
    var processCache = {};
    // 用作储存别名
    window.alias = {};

    // 加载状态标识
    var DONE = &#x27;done&#x27;;
    var REJECTED = &#x27;rejected&#x27;;
    var PENDING = &#x27;pending&#x27;;

    // 获取document,head
    var doc = document;
    var head = doc.head || doc.getElementsByTagName(&quot;head&quot;)[0] || doc.documentElement;

    /**
     * 产生客户端id
     * @return {Number} [description]
     */
    function cid() {
        return _cid++;
    }

    /**
     * Script对象，储存需要加载的任务的基本信息
     * @param  {String} uri     uri 地址 | 需要执行的函数
     * @param  {String} type    任务类型
     */
    function Script(uri, type) {
        this.uri = uri;
        this.type = type;
        this.cid = cid();
        this.status = PENDING;
    }

    /**
     * 从缓存中获取需要的Script对象
     * 如果没有，新建一个
     * @param  {String} uri     uri 地址 | 需要执行的函数
     * @param  {String} type    任务类型
     * @return {Object}         需要的Script对象
     */
    function get(uri, type) {
        // 如果不存在于缓存中，创建一个新的Script对象
        return cache[uri] || (cache[uri] = new Script(uri, type));
    }

    /**
     * 获取真实地址
     * @param  {String} name [description]
     * @return {[type]}      return uri
     */
    function getAlias(name) {
        return alias[name];
    }

    function getCache(uri, type) {
        var opts = getAlias(uri);
        return  opts ? get(opts.uri, opts.type) : get(uri, type);
    }

    // 处理
    var handler = {
        js: jsHandler,
        css: cssHandler,
        fn: fnHandler
    };

    // 对函数的处理
    function fnHandler(context, s) {
        // 函数不需要判断是否为正在加载状态
        try {
            s.uri();
            resolve(context, s);
        }
        catch (e) {
            s.error = e.message;
            resolve(context, s);
        }
    }

    // 对css请求的处理
    function cssHandler(context, s) {
        // 当其他Loader实体中的任务已经完成时
        if (s.status !== PENDING) {
            resolve(context, s);
            return;
        }
        var link = document.createElement(&#x27;link&#x27;);
        link.type = &#x27;text/css&#x27;;
        link.rel  = &#x27;stylesheet&#x27;
        link.href = s.uri;
        head.appendChild(link);
        resolve(context, s);
    };

    // 对js动态加载的处理
    function jsHandler(context, s) {

        // 处理已完成任务
        if (s.status !== PENDING) {
            resolve(context, s);
            return;
        }

        // 如果非第一个加载，将剩余的任务和任务关联的上下文塞进正在进行的进程中
        if (s.changeState) {
            processCache[s.cid] = processCache[s.cid] || [];
            processCache[s.cid].push({ loader: context, s: s });
            return;
        }

        s.changeState = true;

        // 设置超时标志
        var isTimeout = true;
        var script = document.createElement(&#x27;script&#x27;);
        script.async = true;
        script.src = s.uri;

        // 如果支持onload事件
        var hasOnload = &#x27;onload&#x27; in script;


        if (hasOnload) {
            script.onload = jsOnload;
            script.onerror = function () {
                jsOnload(&#x27;ScriptError&#x27;);
            }
        }
        else {
            script.onreadystatechange = function() {
                if (/loaded|complete/.test(script.readyState)) {
                    jsOnload();
                }
            }
        }

        // 如果设置了超时，启动一个计时器
        if (context.timeout) {
            setTimeout(timeoutHandler, context.timeout);
        }

        head.appendChild(script);

        function jsOnload(error) {
            isTimeout = false;
            script.onload = script.onerror = script.onreadystatechange = null;
            head.removeChild(script);
            script = null;
            if (error &amp;&amp; typeof error === &#x27;string&#x27;) {
                s.error = error;
            }
            resolve(context, s);
        }

        function timeoutHandler() {
            if (isTimeout) {
                console.log(&#x27;timeout&#x27;);
                jsOnload(&#x27;RequestTimeout&#x27;);
            }
        }
    }

    function resolve(loader, s) {
        if (s.error) {
            loader.errors.push(s);
        }
        loader.done();
        var cache = processCache[s.cid];
        if (cache &amp;&amp; !cache.length) {
            for (var i = 0, len = cache.length; i &lt; len; i++) {
                cache.shift().loader.done();
            }
        }
    }

    var Loader = function () {
        this.list = [];
        this.errors = [];
        this.timeout = [];
        this.callback = null;
    };

    Loader.prototype.then = function(src, type) {
        if (src === undefined) {
            throw new Error(&#x27;木有参数&#x27;);
        }

        //  修正参数
        if (!type) {
            if (typeof src === &#x27;string&#x27;) {
                if (/\.css$|\.css\?/i.test(src)) {
                    type = &#x27;css&#x27;;
                }
                if (/\.js$|\.js\?/i.test(src)) {
                    type = &#x27;js&#x27;;
                }
            }
            if (typeof src === &#x27;function&#x27;) {
                type = &#x27;fn&#x27;
            }
        }

        type = type || &#x27;js&#x27;;
        this.list.push(getCache(src, type));
        return this;
    };

    Loader.prototype.done = function(cb) {
        if (this.callback === null) {
            this.callback = cb;
        }
        if (!this.list.length) {
            this.callback &amp;&amp; this.callback(this.errors);
            return;
        }
        var script = this.list.shift();
        handler[script.type](this, script);
        if (!this.called) {
            this.called = true;
            return new Loader();
        }
    };

    Loader.prototype.config = function (opts) {
        this.timeout = opts.timeout || 0;
        if (opts.alias &amp;&amp; !opts.alias.length) {
            for (var i in alias) {

            }
            for (var i = opts.alias.length - 1; i &gt;= 0; i--) {
                alias[i] = opts.alias[i]
            }
        }
        return this;
    };

    return Loader;
}));
</code></pre><!-- react-text: 303 -->
<!-- /react-text --><p data-reactid="304">除了此类常规的写法，我们其实还可以使用其他更多的方法来实现脚本动态加载，比如自定义事件，比如模块化加载的实现，比如promise实现等等  </p><!-- react-text: 305 -->
<!-- /react-text --><p data-reactid="306">这篇文章的意义在于开阔思维，回顾基础。  </p><!-- react-text: 307 -->
<!-- /react-text --><p data-reactid="308">下面的observer对象实现了一个简单的事件注册，监听，销毁的功能，对模式有过研究或者码力深厚的同学肯定不陌生。  </p><!-- react-text: 309 -->
<!-- /react-text --><pre data-reactid="310"><code data-query="{}" data-lang="data-lang" data-reactid="311">var observer = (function () {

    var list = {};

    var on = function (evt, cb) {
        if (!list[evt]) {
            list[evt] = [];
        }
        list[evt].push(cb);
    };

    var trigger = function () {
        var evtName = Array.prototype.shift.call(arguments);
        callbacks = list[evtName];
        if (!callbacks || callbacks.length === 0) {
            return;
        }
        for (var i = 0, len = callbacks.length; i &lt; len; i++) {
            callbacks[i].apply(this, arguments);
        }
    };

    var off = function (evt, fn) {
        var callbacks = list[evt];
        if (!callbacks) {
            return;
        }
        if (!fn) {
            callbacks &amp;&amp; callbacks.length = 0;
            return;
        }
        for (var i = 0, len = callbacks.length i &lt; len; i++) {
            if (fn === callbacks[i]) {
                callbacks.splice(i, 1);
            }
        }
    };

    // 暴露对外接口
    return {
        trigger: trigger,
        on: on,
        off: off
    }
})();
</code></pre><!-- react-text: 312 -->
<!-- /react-text --><blockquote data-reactid="313"><!-- react-text: 314 -->
<!-- /react-text --><blockquote data-reactid="315"><!-- react-text: 316 -->
<!-- /react-text --><p data-reactid="317">延伸阅读  </p><!-- react-text: 318 -->
<!-- /react-text --></blockquote><!-- react-text: 319 -->
<!-- /react-text --></blockquote><!-- react-text: 320 -->
<!-- /react-text --><p data-reactid="321"><a href="http://malcolmyu.github.io/malnote/2014/08/30/JavaScript-Promise-In-Wicked-Detail/" data-reactid="322">JavaScript Promise 探微</a><!-- react-text: 323 -->  <!-- /react-text --></p><!-- react-text: 324 -->
<!-- /react-text --><p data-reactid="325"><a href="https://github.com/lifesinger/lifesinger.github.io/issues/170" data-reactid="326">SeaJs源码解析1</a><!-- react-text: 327 -->  <!-- /react-text --></p><!-- react-text: 328 -->
<!-- /react-text --><p data-reactid="329"><a href="https://github.com/lifesinger/lifesinger.github.io/issues/171" data-reactid="330">SeaJs源码解析2</a><!-- react-text: 331 -->  <!-- /react-text --></p><!-- react-text: 332 -->
<!-- /react-text --><p data-reactid="333"><a href="https://github.com/lifesinger/lifesinger.github.io/issues/175" data-reactid="334">SeaJs源码解析3</a><!-- react-text: 335 -->  <!-- /react-text --></p><!-- react-text: 336 -->
<!-- /react-text --><p data-reactid="337"><a href="http://qianduanblog.com/post/headjs.html" data-reactid="338">HeadJs</a></p><!-- react-text: 339 -->
<!-- /react-text --></article><div data-reactid="340"><div class="valine-comment-container" data-reactid="341"></div></div><nav class="single-bar clearfix" data-reactid="342"><span class="prev" data-reactid="343"><a rel="prev" href="/blog/fe/customize-your-chrome-plug-in" data-reactid="344"><em class="eux-icon eux-icon-page-prev" data-reactid="345"></em><!-- react-text: 346 -->定制属于你自己的chrome插件<!-- /react-text --></a></span><span class="next" data-reactid="347"><a rel="next" href="/blog/fe/javascript-loop" data-reactid="348"><em class="eux-icon eux-icon-page-next" data-reactid="349"></em><!-- react-text: 350 -->Javascript事件轮询<!-- /react-text --></a></span></nav></div></div></div><footer class="footer" data-reactid="351"><div class="eux-footer-area-wrapper container-singular" role="complementary" data-reactid="352"><div class="inner clearfix" data-reactid="353"><aside id="simple-links-2" class="widget sl-links-main" data-reactid="354"><h2 class="widgettitle" data-reactid="355">友情链接</h2><ul class="simple-links-list simple-links-2-list" id="simple-links-2-list" data-reactid="356"><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="357"><a href="http://sux.baidu.com" target="_blank" title="百度搜索用户体验中心" data-reactid="358">百度 SUX</a></li><li class="simple-links-item simple-links-widget-item" id="link-362" data-reactid="359"><a href="http://fex.baidu.com/" target="_blank" title="百度 FEX 团队" data-reactid="360">百度 FEX</a></li><li class="simple-links-item simple-links-widget-item" id="link-368" data-reactid="361"><a href="http://efe.baidu.com/" target="_blank" title="百度 EFE 团队" data-reactid="362">百度 EFE</a></li><li class="simple-links-item simple-links-widget-item" id="link-795" data-reactid="363"><a href="https://aotu.io/" target="_blank" title="京东凹凸实验室，面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。" data-reactid="364">凹凸实验室</a></li></ul></aside><!-- react-text: 365 -->          <!-- /react-text --></div></div><div class="eux-icp" data-reactid="366"><!-- react-text: 367 -->百度EUX 版权所有 ©百度EUX    All rights reserved. 骄傲地采用 <!-- /react-text --><a target="_blank" href="https://github.com/picidaejs/picidaejs" data-reactid="368">Picidae</a><!-- react-text: 369 -->。<!-- /react-text --></div></footer></div>
</div>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>