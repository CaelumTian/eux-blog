webpackJsonp([20,40],{923:function(e,n){e.exports={content:'<h2 id="需求"><a href="#%E9%9C%80%E6%B1%82" aria-hidden="true"><span class="icon icon-link"></span></a>需求</h2>\n<ul>\n<li>实现一个输入框，高度可以随着输入文字的增加而自动增高，类似于微信输入</li>\n<li>输入为空时，显示placeholder</li>\n<li>字数限制maxlength</li>\n</ul>\n<h3 id="方法1：使用textarea配合工具函数autosize实现高度自适应的输入框支持ie9，具体代码如下："><a href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8textarea%E9%85%8D%E5%90%88%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0autosize%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E8%BE%93%E5%85%A5%E6%A1%86%E6%94%AF%E6%8C%81ie9%EF%BC%8C%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" aria-hidden="true"><span class="icon icon-link"></span></a>方法1：使用textarea配合工具函数<a href="https://github.com/jackmoore/autosize">autosize</a>实现高度自适应的输入框(支持IE9+)，具体代码如下：</h3>\n<pre><code data-query="{}" data-lang="">&#x3C;!DOCTYPE html>\n    &#x3C;html lang="en">\n    &#x3C;head>\n        &#x3C;meta charset="UTF-8">\n        &#x3C;title>Document&#x3C;/title>\n        &#x3C;style type="text/css">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            textarea {\n                resize: none;\n            }\n        &#x3C;/style>\n    &#x3C;/head>\n    &#x3C;script type="text/javascript" src="js/autosize.min.js">&#x3C;/script>\n    &#x3C;body>\n        &#x3C;textarea id="textarea" rows="1" placeholder="请输入内容..." maxlength="50">&#x3C;/textarea>\n    &#x3C;/body>\n    &#x3C;script type="text/javascript">\n        autosize(document.querySelector(\'#textarea\'));\n    &#x3C;/script>\n    &#x3C;/html>\n</code></pre>\n<p>注：因为textarea的默认高度为rows=2,所以需要将textarea的rows设置为1  </p>\n<h3 id="方法2：div加属性contenteditabletrue"><a href="#%E6%96%B9%E6%B3%952%EF%BC%9Adiv%E5%8A%A0%E5%B1%9E%E6%80%A7contenteditabletrue" aria-hidden="true"><span class="icon icon-link"></span></a>方法2：div加属性contenteditable=true</h3>\n<h4 id="我们知道可以将div的contenteditable设置伪true，将其变为可输入状态。代码如下："><a href="#%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E5%8F%AF%E4%BB%A5%E5%B0%86div%E7%9A%84contenteditable%E8%AE%BE%E7%BD%AE%E4%BC%AAtrue%EF%BC%8C%E5%B0%86%E5%85%B6%E5%8F%98%E4%B8%BA%E5%8F%AF%E8%BE%93%E5%85%A5%E7%8A%B6%E6%80%81%E3%80%82%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" aria-hidden="true"><span class="icon icon-link"></span></a>我们知道可以将div的contenteditable设置伪true，将其变为可输入状态。代码如下：</h4>\n<pre><code data-query="{}" data-lang="">&#x3C;div contenteditable="true">&#x3C;/div>\n</code></pre>\n<p>这样就满足了我们的第一个需求——高度自适应。但是在手机上测试会发现第一个问题，iOS上面无法输入。经过查找资料，发现只需要为其添加如下样式即可:  </p>\n<pre><code data-query="{}" data-lang=""> div{\n    user-select:text;\n    -webkit-user-select:text;\n}\n</code></pre>\n<h4 id="实现placeholder"><a href="#%E5%AE%9E%E7%8E%B0placeholder" aria-hidden="true"><span class="icon icon-link"></span></a>实现placeholder</h4>\n<h4 id="使用cssjs实现-placeholder，思路：根据输入通过动态添加class，模拟placeholder的行为，代码如下"><a href="#%E4%BD%BF%E7%94%A8cssjs%E5%AE%9E%E7%8E%B0-placeholder%EF%BC%8C%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%A0%B9%E6%8D%AE%E8%BE%93%E5%85%A5%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0class%EF%BC%8C%E6%A8%A1%E6%8B%9Fplaceholder%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B" aria-hidden="true"><span class="icon icon-link"></span></a>使用css+js实现 placeholder，思路：根据输入通过动态添加class，模拟placeHolder的行为，代码如下:</h4>\n<pre><code data-query="{}" data-lang="">// css\n.textarea {\nwidth: 400px;\nmin-height: 20px;\nmax-height: 300px;\n_height: 120px;\nmargin-left: auto;\nmargin-right: auto;\npadding: 3px;\noutline: 0;\nborder: 1px solid #a0b3d6;\nfont-size: 12px;\nline-height: 24px;\npadding: 2px;\nword-wrap: break-word;\noverflow-x: hidden;\noverflow-y: auto;\nborder-color: rgba(82, 168, 236, 0.8);\nbox-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);\nposition: relative;\nuser-select: text;\n-webkit-user-select: text;\n}\n.placeholder:before {\ncontent: \'请输入内容...\';\nline-height: 30px;\nposition: absolute;\nleft: 5px;\ntop: 0;\nz-index: 1;\n}\n// html\n&#x3C;div class="textarea placeholder" contenteditable="true" data-placeholder="请输入内容..." data-length="10">&#x3C;br />&#x3C;/div>\n// js\nvar oInputBox = document.querySelector(\'.textarea\');\noInputBox.oninput = oInputBox.onpropertychange = function (ev) {\nvar innterStr = oInputBox.innerText;\nvar _this = this;\n\n// placeholder\nif (innterStr.length == 0) {\n_this.classList.add(\'placeholder\');\n} else {\n_this.classList.remove(\'placeholder\');\n}\n};\n</code></pre>\n<p>到此，我们已经实现了第二个需求——可以设置placeholder  </p>\n<h4 id="实现maxlength"><a href="#%E5%AE%9E%E7%8E%B0maxlength" aria-hidden="true"><span class="icon icon-link"></span></a>实现maxlength</h4>\n<p>同样的，我们也不能通过直接设置maxlength来满足需求。所以通过监听input事件来实时计算长度。  </p>\n<pre><code data-query="{}" data-lang="">var oInputBox = document.querySelector(\'.textarea\');\noInputBox.oninput = oInputBox.onpropertychange = function (ev) {\n    var innterStr = oInputBox.innerText;\n    var _this = this;\n\n    // maxlength\n    var len = parseInt(_this.getAttribute(\'data-length\'));\n    if (innterStr.length > len) {\n        oInputBox.innerText = innterStr.substring(0,len);\n    }\n};\n</code></pre>\n<p>以上代码看上去没有问题，但是会发现光标会跑到最前方，这样就会造成不好的用户体验，甚至出现Bug。所以在截取了最大长度的用户输入后，我们还需要将光标放到最后。完整JS代码如下：  </p>\n<pre><code data-query="{}" data-lang="">var oInputBox = document.querySelector(\'.textarea\');\noInputBox.oninput = oInputBox.onpropertychange = function (ev) {\n    var innterStr = oInputBox.innerText;\n    var _this = this;\n\n    // placeholder\n    if (innterStr.length == 0) {\n        _this.classList.add(\'placeholder\');\n    } else {\n        _this.classList.remove(\'placeholder\');\n    }\n    // maxlength\n    var len = parseInt(_this.getAttribute(\'data-length\'));\n    if (innterStr.length > len) {\n        oInputBox.innerText = innterStr.substring(0,len);\n    }\n\n    // div innerText重新赋值之后的光标问题\n\n    if(navigator.userAgent.indexOf(\'MSIE\') > -1) {\n        var range = document.selection.createRange();\n        _this.last = range;\n        range.moveToElementText(_this);\n        range.select();\n        document.selection.empty(); //取消选中\n    } else {\n        var range = document.createRange();\n        range.selectNodeContents(_this);\n        range.collapse(false);\n        var sel = window.getSelection();\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n};\n</code></pre>\n<p>到此为止，一个可以自动增加高度，并且支持placeholder和maxlength的输入框就完成了。  </p>\n<h3 id="要点总结："><a href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%9A" aria-hidden="true"><span class="icon icon-link"></span></a>要点总结：</h3>\n<ul>\n<li>方法1：autosizejs方法通过监听textarea的input、keyup事件动态的获取其scrollHeight，计算出实际高度并配合overflow属性的改变来动态的改变 textarea的高度，此方法使用的时候需要注意的是textarea的rows属性要设置为1，两行以内的高度自适应就会出现问题；兼容性：IE9+</li>\n<li>方法2：div设置contentEditable为true后，输入或删除内容时，其高度本身就会随着内容的变化而变化，我们需要解决的问题只是在输入过程中光标的位置问题；兼容性：IE11及其他高级浏览器</li>\n</ul>\n<h3 id="参考资料："><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A" aria-hidden="true"><span class="icon icon-link"></span></a>参考资料：</h3>\n<p><a href="https://github.com/jackmoore/autosize">autosize</a>  </p>\n<p><a href="https://juejin.im/post/591132902f301e006c304e8e">高度自适应输入框</a></p>\n',extra:{}}}});